---
layout: post
title: "goorm bfs 43082"
date: 2013-03-01 08:26:28 -0400
noindex: true
---

> [최단 거리 구하기](https://level.goorm.io/exam/43082/%EC%B5%9C%EB%8B%A8-%EA%B1%B0%EB%A6%AC-%EA%B5%AC%ED%95%98%EA%B8%B0/quiz/1)

---

## IDEA
bfs
: 인접 행렬
: 단순 경로

## INPUT && OUTPUT
```
5
1 1 1 1 1
0 0 0 0 1
1 1 1 1 1
1 0 0 1 0
1 1 1 1 1

11
```

## CODE
```java
public class Main {
	public static int[] dy = { 1, -1, 0, 0 };
	public static int[] dx = { 0, 0, 1, -1 };
	public static int[][] map;
	public static boolean[][] visited;
	public static int n;
	public static Queue<Point> queue = new LinkedList<>();

	public static void main(String[] args) throws Exception {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		n = Integer.parseInt(br.readLine());
		map = new int[n][n];
		visited = new boolean[n][n];
		for (int i = 0; i < n; i++) {
			String[] input = br.readLine().split(" ");
			for (int j = 0; j < n; j++)
				map[i][j] = Integer.parseInt(input[j]);
		}
		solve();
	}

	public static void solve() {
		visited[0][0] = true;
		queue.add(new Point(0, 0, 1));
		bfs();
	}

	public static void bfs() {
		while (!queue.isEmpty()) {
			Point point = queue.poll();
			if (point.y == n - 1 && point.x == n - 1) {
				System.out.println(point.count);
				return;
			}
			for (int j = 0; j < 4; j++) {
				int ny = point.y + dy[j];
				int nx = point.x + dx[j];
				if (ny >= 0 && ny < n && nx >= 0 && nx < n) {
					if (map[ny][nx] == 1 && !visited[ny][nx]) {
						visited[ny][nx] = true;
						queue.add(new Point(ny, nx, point.count + 1));
					}
				}
			}
		}
	}
}

class Point {
	int y; // 열
	int x; // 행
	int count; // 카운트

	Point(int y, int x, int count) {
		this.y = y;
		this.x = x;
		this.count = count;
	}
}
```

## COMMENT
* bfs + 인접행렬
